# 目录

- [关键字](#关键字)
- [.cpp编译流程](#.cpp编译流程)

- [运算符和操作符的区别](#运算符和操作符的区别)
- [文件名后缀.hpp一般用来标识这个文件里面是类模板](#文件名后缀.hpp一般用来标识这个文件里面是类模板)
- [函数模板和普通函数的区别](#函数模板和普通函数的区别)
- [在定义一个类模板的对象的时候,必须要显示初始化](#在定义一个类模板的对象的时候,必须要显示初始化)
- [函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候](#函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候)
- [在C++编译器中, 普通函数的选择优先级 比 函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).](#在C++编译器中, 普通函数的选择优先级 比 函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).)

- [二次编译](#二次编译)
- [函数模板标准格式和调用](#函数模板标准格式和调用)
- [类模板的标准格式和调用](#类模板的标准格式和调用)
  - [类模板中的友元函数和普通函数声明和重载](#类模板中的友元函数和普通函数声明和重载)
- [类型转换](#类型转换)
- 



- ==模版会导致代码的膨胀==

## 关键字

```c++
本笔记内的关键字:  都是重点内容(毫无水分)全部要掌握!
template  , friend , virtual  , operator  ,private  ,protected, public  ,
模板关键字, 友元   ,  虚和纯虚, 重载操作符,私有成员 ,保护成员 , 公有成员,

cerr    , clog    , ios::out , ios::app ,  ios::in , ios::binary , fstream.close(),
标准错误, 标准日志, 覆盖输出 , 添加输出 ,  只读模式, 二进制模式  ,   关闭文件    ,

throw , try, catch
异常处理

static_cast, dynamic_cast, const_cast,reinterpret_cast
强制类型转换运算符.

cin.get(无参数)  ,cin.get(一个参数), cin.get(两个参数), cin.getlen(), cin.ignore()
一次只能读一个字符,    读一个字符     , 可以读字符串     , 
cin.peek(), cin.putback()
```



### .cpp编译流程

- **index.cpp 编译流程: (这是个普通的源文件)**
  - **`index.cpp -> 通过 预编译器 -> index.i`  (只是把需要的头文件之类的放入一个文件内,把宏定义展开和替换).**
  - **`index.i   -> 通过 编译器   -> index.s 汇编文件`** 
  - **`index.s   -> 通过 汇编器   -> index.obj (linux是.o)  目标文件`**
  - **`index.o   -> 通过 链接器   -> index.exe (linux是.out) 执行文件` (找到调用函数的函数实现).**
- **`$ g++ -E index.cpp -o index.i`     // 该命令会生成 index.i 通过预编译**
- **`$ g++ -S index.i   -o index.s`     // 该命令会把 .i 文件编译成 index.s 汇编文件.**
- **`$ g++ -c index.s   -o index.o`     // linux下是.o  win 下是.obj   ,该命令会生成目标文件**
- **`$ g++ index.s      -o index`       // 链接不需要命令, 直接就可以把.s 文件写在上面, 生成执行文件.**



### 运算符和操作符的区别

- ==操作符是嵌在每一条指令中的，换句话说，指令系统的每一条指令都有一个操作符。是计算机系统中的术语.==
  - 如=（赋值），==（判断相当），+，- 等等。
- ==运算符是数学中的术语。主要是指数之间的运算方式.==
  - 如 + - * / %，但不包括 = （赋值）这样的操作符。



### 文件名后缀.hpp一般用来标识这个文件里面是类模板

**在编写类模板的时候,类模板和函数模板分开两个文件来写**

**那么要把.cpp变成.hpp ,声明 .h 不变, 但是在使用的时候,要引用.hpp,不要引用.h, 这样才不会报错(.hpp 去引用.h).**

**而且.hpp 一般用来标识这个文件里面是类模板.**



### 函数模板和普通函数的区别

==**函数模板和 普通函数的区别是 : 普通函数会进行自动类型转换, 但是函数模板却严格检查类型,不会自动转换.**==



### 在定义一个类模板的对象的时候,必须要显示初始化

==**在定义一个类模板的对象的时候,必须要显示初始化`( CLASS<int> object; //定义一个int类型的类对象)`**==



### 函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候

==**函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候!!!(而且还是以单文件为基准).**==



### 在C++编译器中, 普通函数的选择优先级 比 函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).

==**在C++编译器中, 普通函数的选择优先级 比 函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).**==



## 二次编译

- **二次编译:**
  - **第一次编译其模板(不会出现具体函数,只有调用的时候才会生成具体的函数),函数声明也不会编译.**
  - **第二次编译模板的时候,会查看在 `本文件中` 有没有调用他的函数,如果有就生成,没有就不生成.**
    - ==**(但是 如果在其他文件中调用这个函数模板,那么将会失败,因为找不到通过模板实例化的函数)**==
      - ==**和c++ 独立编译有关系, 这些东西都卡在 连接器那里 也就是 .o 到 .out 的过程中.**==
      - **使用 `.hpp` 后缀即可**



## 函数模板标准格式和调用

```c++
template<class T>     // 也可以这么写 template<typename T> , 多类型的话就添加 class T,class A,
void MySwap(T& a,T& b);   // 把 T 替换    

/* 
 * 使用:
 */
MySwap(10,20);              // 1 使用自动类型推导 
MySwap<double>(3.1, 5.3);   // 2 使用显示指定类型  
MySwap<>(10,20);            // 这样写可以防止被同名函数重载, 让编译器强制调用函数模板.(类型匹配的)
```

- **模板有调用两种类型: 1 自动类型推导, 2 显示的指定类型.** 
- **使用函数模板的时候,编译器会根据你传的值,进行自动类型推导.**
- ==**使用模板的时候,函数模板可以自动类型推导 `(不加<>尖括号就是自动推导)` **==
  - ==**但是类模板是不可以自动类型推导的.**==
- ==**函数模板不会进行自动类型转化,而是严格的类型匹配,(普通函数会进行隐式自动类型转化, 这点要注意!!).**==
- ==**函数模板可以像普通函数一样被重载,(就好比两个同名函数,一个是模板一个是普通函数, 一样都可以发生重载).**==
- ==**C++编译器会优先考虑和调用普通函数,如果普通函数没有匹配的类型,才会考虑模板类型.!!!**==
- **函数模板是不能进行直接调用的,而是通过这个模板来 `实例化(生成)` 与传入类型相配的具体函数.**
- ==**如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现文件改为 .hpp 给主函数**==



## 类模板的标准格式和调用

```c++
template<class T>   //这个T 非函数T, 而是替代了类内的某个类型而以.
class Person{
public:
    Person(T a1, T b1):a(a1),b(b1) {}
        
    void Show(){
       std::cout << a << b << std::endl;
    }
        
private:
    T a;
    T b;
};

int main(void){
    Person<double>pr(10.3,20.4);   //这样来使用类模板, 使T 变成了 double
    pr.Show();
}
```

- ==**函数模板在调用的时候,可以自动类型推导,类模板必须显示指定类型.(比如: Person<int>pr; 就是添加<> 尖括号,).**==
- ==**如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现文件改为 .hpp 给主函数**==



### 类模板中的友元函数和普通函数声明和重载

- ==**这是个坑 ,尽量不要用**==

```c++
template<class T>class Pre;  //首先开始声明
template<class T>void Pre_FRIEND(Pre<T>& p);  // 这是普通友元函数模版声明
template<class T>ostream& operator<<(ostream& os, Pre<T>& p);  // 友元重载


template<class T>   // 类模板开始
class Pre {
public:
    Pre(T& a, T& b);  // 写在外部 构造函数

    void print();  //写在外部 普通函数

    friend void Pre_FRIEND<T>(Pre<T>& p); //写在外部 普通友元函数

    friend ostream& operator<< <T>(ostream& os, Pre<T>& p);  // 写在外部 友元重载操作符

    ~Pre(); //写在外部 析构函数
private:
    T a;
    T b;
};


template<class T>   //要注意 T 的次数  哪个都不能少
Pre<T>::Pre(T& a, T& b) {  //构造函数
    this->a = a;     //函数体没变化
    this->b = b;
}


template<class T>
void Pre<T>::print() {  //普通函数
    cout << "xxxx" << endl;  //函数体没变化
}

template<class T>
void Pre_FRIEND(Pre<T>& p) { //友元函数
         //函数体没变化
}
template<class T>
ostream& operator<<(ostream& os, Pre<T>& p) {  //友元重载操作符  注意T
    os << "a " << p.a << ", b " << p.b << endl;  //函数体没变化
    return os;
}

template<class T>
Pre<T>::~Pre() { //析构函数
        //函数体没变化
}
```

- ==**一定要注意 函数名和各个地方的 `template` 和 `calss T`   和 `T` 的位置和次数,  非常重要.**==
- ==**如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现文件改为 .hpp 给主函数**==

- ==**类模板中如果出现 static 成员,那么每一种实例化都会有自己单独的一个static 的值,和其他的实例化不相同.**==

- ==**派生类的时候也要具体化,就算派生类也是模板的话,也要具体化`( template<class T>class SU:public Pre<T>{})`**==





## 类型转换

- **类型转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方法,**
  - **为了类型转换一个简单对象为另一个对象你会使用传统的类型转换操作符.**
- ==**c 风格的强制类型转换,不管什么是什么类型,统统都是 Type b = (Type)a;  (不会进行类型检查)**==
- ==**c++ 风格的类型转换提供了 4 种类型转换操作符来因对不同场合的应用.    (会对类型进行检查)**==
- ==**C++风格的强制类型转换关键字是运算符**==

- **C++ 风格的强制类型转换关键字(运算符):**
  - ==**`static_cast`   一般的转换,用在内建基础数据类型,指针和引用.   (会有类型检查)**==
    - **用于,内置的数据类型,还有具有继承关系的引用和指针.**
    - `double a = static_cast<char>(t); // t是 int 类型`
  - ==**`dynamic_cast`  通常在 基类 和派生类之间进行转换时使用,有继承关系的. 动态类型转换**==
    - **只能转换具有继承关系的指针或者引用, 只能由子类型转换到父类型.**
  - ==**`const_cast`    主要针对 const 的转换,只能对指针,引用.或者对象指针,增加const引用或者去掉const.**==
    - **转化之前会做安全检查,(绝对不可以对 对象使用,可以借助指向对象的指针或引用)**
  - ==**`reinterpret_cast`  用于进行没有任何关联之间的转换,比如字符指针转换为整形数.(跟c差不多).**==
    - **没有安全检查,什么都能转, 比如class指针 转成函数指针.**

```c++
// 基础数据类型
    int  a  = 97;
    char c  =  static_cast<char>(a);   // 是基础类型可以转换
    char c1 =  dynamic_cast<char>(a);  //该转换会报错, 不可以转换 非指针或引用的类型
    cout << c  << endl;      // static_cast 转换后会输出一个字符 a  (ascll 码97就是a)

    const int& ca = a;
    int& ca1 = const_cast<int&>(ca);   // 可以转换,而且去除了const ,可以通过ca1进行修改了.
    ca1 = 30;                          //  通过ca1 修改了a 的值,但是不可以直接对a 进行赋值
                                       //  也就是 ca 原有const 属性还是存在的.
    int* p =NULL;
    const int* p1 = const_cast<const int*>(p);  // 这样也是可以的,但仅仅p1具有const
    *p = 30;                           //虽然p1 指针具有const效应, 但是p 没有变,他还是可以修改.
   

// 基础数据类型指针或引用
    int*   p = NULL;
    char* sp = static_cast<char*>(p);   // 这样转换是会报错的,无法编译
                                        // 不允许从'int *'到'char *'的转换

//对象指针 和 引用
    class A{};              // A 是C 的父类
    class B{};              // B 无继承
    class C: public A{};    // C 继承 A
      A* a1 = NULL;
      B* b1 = NULL;
      C* c1 = NULL; 
    
    A* a2 = static_cast<A*>(b1);  // 错误的转换,无法转换的类型,因为他们没有继承关系
    B* b2 = static_cast<B*>(c1);  // 错误的转换,无法转换的类型,因为他们没有继承关系
	  C* c2 = static_cast<C*>(a1);  // 父类指针可以转换为子类指针 (不安全)

    A* a3 = dynamic_cast<A*>(c1);   // 子类转换为父类的指针是可以的 不会出现内存访问越界
    B* b3 = dynamic_cast<B*>(c1);   // 错误的转换,两个毫无关系的类 是无法进行转换的
    C* c3 = dynamic_cast<C*>(a1);   // 错误的转换,父类转换子类内存会越界,dynamic_cast 会直接报错
    
    A a;
    B b;
    C c;
    
    A& a3 = a;   //正常的引用
    C& c3 = c;
    C& c4 = static_cast<C&>(a3);  // 父类引用可以转换为子类引用 (不安全)
    A& a4 = static_cast<A&>(c3);  // 子类引用也可以转换为父类引用
    


```







