**指针强化:    `[]` 优先级比 `*` 高**

- 指针也是一种数据类型,指针变量也是一种变量,可以储存其他类型数值的地址.
- 指针指向谁,就把谁的地址赋值给指针.
  - `*钥匙,通过*可以找到指针指向的内存区域,操作的还是内存.`
  - `*放在=左边,给内存赋值,写内存. int a = 0;  int *p = a;`
  - `*放在=右边,取内存的值,读内存. int b = *p;`
- 指针变量,和指向 指向的内存是两个不同的概念.
- 指针自己也有地址和内存,它储存的是指向的对象的地址(%p 指向的地址(十六进制)).
- 指针 p = p + 1 ; 会得到所指元素类型的下一个元素(int 就是+4,char +1).
- 当函数中有数组参数,都会退化成指针,所以不会知道数组有多大,只能知道这个指针有多大(4字节).
- **间接赋值是指针存在的最大意义:**
  - 间接赋值三大条件:  1) 两个变量.  2)建立关系.  3) 通过* 操作符进行间接赋值.



## 二级指针和指针数组和多级指针强化

- 如果一个指针变量存放的又是另一个指针变量的地址,则成这个指针变量为指向指针的指针变量.也称二级指针.
- 函数形参应该使用二级指针,传入的参数应该使用一级指针,这样就可以用被调函数来进行内存操作了.
- 

```c
指针数组. char *p[3]={"11","22",p2};  //存储指针,也存储指向字符串指针,都是地址(4字节),使用时p[2];
    二级指针数组 char **p1[3] = {p6,p2,p3}; // 里面都是二级指针.
               char **p = (char**)malloc(n*sizeof(char*)); //分配内存,n个指针(4字节),仅仅只是指针.

    多级指针数组 char ***p7[3] = {p4,p5;};
    指向指针数组的指针 char *(*p8)[3] = &p;
    数组指针 char (*pp)[5] ;   //指向 char [5] 数组的指针.
             char *(*pa)[6];   //指向 char *[6] 指针数组的指针.
             int a[5];  int *A[5] = &a;  //指向整个数组,而不是首元素地址.
             A++ ; //会跳 5*4 = 20个 字节.而不是单纯跳指针.指向的类型不同,导致步长不一样.
             
             typedef int A[10]; A *b;  // b 是指向一个int [10] 数组的一个指针.
             typedef char (*a)[3]; a pp;  // pp是指向 char [3] 数组的一个指针.

!!声明中一旦()内只有一个*则这是一个指针,如果出现(*p[5]) 则这是一个数组,里面存放着5个指针.
  二级指针的数组和指向对象使用排序法时,应该使用strcpy()来互换内存块数据,而不是互换指针.!!!
  有typedef 就是类型,没有就是变量.
```

- **`二维数组中心思想: int a[i][q];   *(*(a+i)+j) 等价于 &a[i][q] 等价于 a[i][j];`**

  - `数组首元素和数组元素地址不同,步长不同,a[0] =数组元素地址4, &a = 首元素地址`

  - `二维数组本质就是一位数组,是线性存储的,可以使用一个总元素个数的循环搞定输出.`

  - ```c
    a ;   //代表第0行首地址,也就是整个数组的地址.
    a+i -> &a[i] ; //代表第i 行首地址.
    *(a+i) -> a[i] ; //代表第0行首元素地址.
    *(a+i)+q  -> &a[i][q] ;  //第 i行 第q 列元素的地址.
    *(*(a+i)+q)  -> a[i][q] ;  // 第i 行 第q列 元素的值.
    例: int a[3][4];  int (*P)[4] = a;  *(*(P+i)+w) = a[i][w];
    ```

- 一维数组

  - ```c
    一维数组 int a[10];    
           a ;   //表示数组首行首元素地址, 是 一级指针.
           &a;   //表示数组的首元素地址, 是 二级指针.
           a+1;  //表示 跳过1元素,一元素 为4字节, 步长为4字节.
           &a+1; //表示 跳过整个数组, 整个数组长度 10*4 =40 , 步长为 40.
          sizeof(a) ;  //传参为: 数组首行首元素的地址,测数组 (int a[10]) 的长度, 10*4= 40;
          sizeof(a[0]); //传参为: 数组首元素(不是地址), 每个元素为 int 类, 4字节;
          sizeof(&a);   //传参为: 一维数组整个数组的地址(首行地址),编译器当做指针类型,4字节;
    ```

- **`!!(重要) 首行地址  转换为 行首元素地址(加*);`**

  - `&a; //首行地址`
  - `*&a;//首行首元素地址`

- **`!!(重要) 如果想在函数内改变主函数变量的值 应该这么写:`**

  - ```c
        int main(void){  long  n = 0 ; swap (&n);}     
        void swap(long *n){ *n = 0;}
        这样就可以来间接修改主函数内的值.
    ```





## 指针做函数参数的输入输出特性

- 输入: 主调函数分配内存.
- 输出: 被调用函数分配内存.
- **被调用函数是在 堆区(heap) 上分配内存,而不是 栈区(stack)上.否则会被销毁的可能.**

```c
例:int main() { char * std = NULL; macpy(&std);}

macpy(char **std){ char * sdr =malloc(100); strcpy(sdr,"aa"); *std = sdr;free(sdr);sdr=NULL;}
        // 这样就可以用被调函数来进行内存操作了,得需要二级指针.
    函数内 int ** p; int * k;   *p = k;   //这样可以间接赋值,一级和二级指针的赋值.
       
strlen(数组); 测字符串长度,不包括数字0,字符\0.是数组中元素的个数的真正长度;(数组一般都用这个)
sizeof(数组); 测数组长度, 包含数字0,字符\0. 是数组定义时的长度,而不是元素个数,所以比stlen()多;
	   char str[100]="abcd";    sizeof(str); //返回100     stdlen(str); //返回4
	   char str2[] ="abcdef";   sizeof(str2); //返回7      stdlen(str); //返回6	
	
char* strstr(cosnt char *str1,const char * str2); //从str1中查找与str2相同的字符串然后返回地址,否则NULL.

int isspace(char c); //检查c是否为空格和\n,\t,\r,\v,\f .找到返回true 否则false.,这是宏不是函数,<ctype.h>

int strcmp(char *str1,char* str2); 比较两个字符串,1比2大就返回正数,相等是0.
int strcpy(char *str1,char* str2);  将2的字符串拷贝给1,不会添加 '\0' .
char* strstr(char *str1,char* str2); 从1中查找2,找到返回指指向那里的指针,没找到NULL.

sizeof(char *)   = 4  ;   //无论多少*   都是等于4 ;
char ** name = (char**) malloc(sizeof(char*) *3 );    // 给二级指针申请内存,使用时还需要向下继续
  name[0] = (char*)malloc(30); //继续申请30个字节内存空间,由name[0]元素指向.然后就可以存入数据了.
  sstrcpy(name[0],"lllasd");  // 将字符串存入, 然后打印时当数组 printf("%s",name[0]); 就可以了.
char*  可以指向数组的.
```











