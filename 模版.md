# 目录

- [关键字](#关键字)
- [文件名后缀.hpp一般用来标识这个文件里面是类模板](#文件名后缀.hpp一般用来标识这个文件里面是类模板)
- [函数模板和普通函数的区别](#函数模板和普通函数的区别)
- [在定义一个类模板的对象的时候,必须要显示初始化](#在定义一个类模板的对象的时候,必须要显示初始化)
- [函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候](#函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候)
- [在C++编译器中,普通函数的选择优先级比函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).](#在C++编译器中,普通函数的选择优先级比函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).)
- [二次编译](#二次编译)
- [函数模板标准格式和调用](#函数模板标准格式和调用)
- [类模板的标准格式和调用](#类模板的标准格式和调用)
  - [类模板中的友元函数和普通函数声明和重载](#类模板中的友元函数和普通函数声明和重载)
- [模版的不定参数,可变参](#模版的不定参数,可变参)
- [使用explicit关键字阻止隐式类型转换](#使用explicit关键字阻止隐式类型转换)
- 



==**模版会导致代码的膨胀**==

## 关键字

```c++
本笔记内的关键字:  都是重点内容(毫无水分)全部要掌握!
template  , friend , virtual  , operator  ,private  ,protected, public  
模板关键字  , 友元   ,  虚和纯虚  , 重载操作符 ,私有成员   ,保护成员  , 公有成员,

cerr   , clog   , ios::out , ios::app ,  ios::in , ios::binary , fstream.close()
标准错误, 标准日志 , 覆盖输出  , 添加输出  ,  只读模式  , 二进制模式   ,   关闭文件    

throw , try, catch
异常处理

static_cast, dynamic_cast, const_cast,reinterpret_cast
强制类型转换运算符.

cin.get(无参数)  ,cin.get(一个参数), cin.get(两个参数), cin.getlen(), cin.ignore()
一次只能读一个字符,    读一个字符     , 可以读字符串     , 
cin.peek(), cin.putback()
```





### 文件名后缀.hpp一般用来标识这个文件里面是类模板

**在编写类模板的时候,类模板和函数模板分开两个文件来写**

**那么要把.cpp变成.hpp ,声明 .h 不变, 但是在使用的时候,要引用.hpp,不要引用.h, 这样才不会报错(.hpp 去引用.h).**

**而且.hpp 一般用来标识这个文件里面是类模板.**



### 函数模板和普通函数的区别

**函数模板和 普通函数的区别是 : 普通函数会进行自动类型转换, 但是函数模板却严格检查类型,不会自动转换.**



### 在定义一个类模板的对象的时候,必须要显示初始化

**在定义一个类模板的对象的时候,必须要显示初始化`( class<int> object; //定义一个int类型的类对象)`**



### 函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候

**函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候!!!(而且还是以单文件为基准).**



### 在C++编译器中,普通函数的选择优先级比函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).

**在C++编译器中, 普通函数的选择优先级 比 函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).**



## 二次编译

- **二次编译:**
  - **第一次编译其模板(不会出现具体函数,只有调用的时候才会生成具体的函数),函数声明也不会编译.**
  - **第二次编译模板的时候,会查看在 `本文件中` 有没有调用他的函数,如果有就生成,没有就不生成.**
    - **(但是 如果在其他文件中调用这个函数模板,那么将会失败,因为找不到通过模板实例化的函数)**
      - **和c++ 独立编译有关系, 这些东西都卡在 链接器 那里 也就是 .o 到 .out 的过程中.**
      - **使用 `.hpp` 后缀即可**



## 函数模板标准格式和调用

```c++
template<class T>     // 也可以这么写 template<typename T> , 多类型的话就添加 class T,class A,
void MySwap(T& a,T& b);   // 把 T 替换    

// 使用:
MySwap(10,20);              // 1 使用自动类型推导 
MySwap<double>(3.1, 5.3);   // 2 使用显示指定类型  
MySwap<>(10,20);            // 这样写可以防止被同名函数重载, 让编译器强制调用函数模板.(类型匹配的)
```

- **模板有调用两种类型: 1 自动类型推导, 2 显示的指定类型.** 
- **使用函数模板的时候,编译器会根据你传的值,进行自动类型推导.**
- **使用模板的时候,函数模板可以自动类型推导 `(不加<>尖括号就是自动推导)` **
  - **但是类模板是不可以自动类型推导的.**
- **函数模板不会进行自动类型转化,而是严格的类型匹配,(普通函数会进行隐式自动类型转化, 这点要注意!!).**
- **函数模板可以像普通函数一样被重载,(就好比两个同名函数,一个是模板一个是普通函数, 一样都可以发生重载).**
- **C++编译器会优先考虑和调用普通函数,如果普通函数没有匹配的类型,才会考虑模板类型.!!!**
- **函数模板是不能进行直接调用的,而是通过这个模板来 `实例化(生成)` 与传入类型相配的具体函数.**
- **如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现文件改为 .hpp 给主函数**



## 类模板的标准格式和调用

```c++
template<class T>   //这个T 非函数T, 而是替代了类内的某个类型而以.
class Person{
public:
    Person(T a1, T b1):a(a1),b(b1) {}
        
    void Show(){
       std::cout << a << b << std::endl;
    }
        
private:
    T a;
    T b;
};

int main(void){
    Person<double>pr(10.3,20.4);   //这样来使用类模板, 使T 变成了 double
    pr.Show();
}
```

- **函数模板在调用的时候,可以自动类型推导,类模板必须显示指定类型.(比如: `Person<int>pr;` 就是添加<> 尖括号,).**
- **如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现和定义都写入 .hpp文件再给 给主函数**





### 类模板中的友元函数和普通函数声明和重载

- **这是个坑 ,尽量不要用**

```c++
template<class T>class Pre;  //首先开始声明
template<class T>void Pre_FRIEND(Pre<T>& p);  // 这是普通函数模版声明 , 即将被类友元
template<class T>ostream& operator<<(ostream& os, Pre<T>& p);  // 会被友元的模版操作符重载函数


template<class T>   // 类模板开始
class Pre {
public:
    Pre(T& a, T& b);  // 写在外部 构造函数
    void print();  //写在外部 普通函数
    friend void Pre_FRIEND<T>(Pre<T>& p); //将外部的一个模版函数 进行友元化
    friend ostream& operator<< <T>(ostream& os, Pre<T>& p);  // 写在外部 友元重载操作符
    ~Pre(); //写在外部 析构函数
public:
    T a;
    T b;
};

template<class T>   //要注意 T 的次数  哪个都不能少
Pre<T>::Pre(T& a, T& b) {  //构造函数
    this->a = a;     //函数体没变化
    this->b = b;
}

template<class T>
void Pre<T>::print() {  //普通函数
    cout << "xxxx" << endl;  //函数体没变化
}

template<class T>
void Pre_FRIEND(Pre<T>& p) { //友元函数
         //函数体没变化
}
template<class T>
ostream& operator<<(ostream& os, Pre<T>& p) {  //友元重载操作符  注意T
    os << "a " << p.a << ", b " << p.b << endl;  //函数体没变化
    return os;
}

template<class T>
Pre<T>::~Pre() { //析构函数
        //函数体没变化
}
```

- **一定要注意 函数名和各个地方的 `template` 和 `calss T`   和 `T` 的位置和次数,  非常重要.**
- **如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现文件改为 .hpp 给主函数**
- **类模板中如果出现 static 成员,那么每一种实例化都会有自己单独的一个static 的值,和其他的实例化不相同.**
- **派生类的时候也要具体化,就算派生类也是模板的话,也要具体化`( template<class T>class SU:public Pre<T>{})`**
- ==**就算是友元 , 也不能访问 类的私有成员.**==



## 模版的不定参数,可变参

- 可以用在创建某个类对象上, ...args 会直接检查所需要的参数是否可以构成某个对象. 会在编译阶段直接报错

```c++
template <typename ...Args >
static Type* createObject(Args ... args)    // 不定参数, 用这些参数去初始化和创建某个类型
  Type* obj = new Type(args...);  
  return obj;
}




template<class ...Args>
static void Info(const char* pformat, Args ... args) {
    printf(pformat, args...);
}

```



## 使用explicit关键字阻止隐式类型转换

**`explicit`只能应用于构造函数或转换函数**

```c++
template<class T>
class B{
public:
  // “ explicit”只能应用于构造函数或转换函数
  	explicit B(int c);   //构造函数只可以传入 int 的值, 不可以传入其他的, 但不限定手动强制类型转换
};


B(2) ;  // 可以
B( 2.4);   // 不可以
B( static_cast<int>(3.3) );   // 可以的
```

