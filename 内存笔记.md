- [内存四区](#内存四区)
- [内存分段](#内存分段)
  - [内存分段和内存分页一样都是一种内存管理技术](#内存分段和内存分页一样都是一种内存管理技术)
  - [分段的好处](#分段的好处)
- [CPU寄存器](#CPU寄存器)
- [堆区栈区全局区代码区](#堆区栈区全局区代码区)



> **函数代码存放在代码段。声明的类如果从未使用，则在编译时，会优化掉，其成员函数不占代码段空间。**

## 内存四区

1. 数据类型的本质: 是固定内存大小的别名.

   1. 数据类型的作用: 编译器预算对象(变量)分配的内存空间大小.
      1.  注: 数据类型只是模具，编译器并没有分配空间,只有根据具体类型(模具)创建变量(实物)，编译器才会分配内存空间.
      2. void 类型只有指针没有普通类型,因为指针在32位是占4字节,64位则占8个字节不变,所以只有void的指针.
      3. void 的类型不能够直接确定,所以定义普通定义的时候将会无法知道他需要多少内存,也就无法继续编译.
         1. void 类型指针可以被赋值,但是必须要强制类型转换,无论使用还是赋值.
   2. **函数 也是一种数据类型,它可以自定义类型,有函数指针,也是入口地址.**

2. 变量的概念: 既能读又能写的 内存对象. 若一但初始化后不能修改的对象则成为常量.

   1. 变量的本质: 一段连续内存空间的别名. 变量就相当于门牌号, 内存相当于房间,互为查找.数据类型当做模具,变量是根据模具创建出来的实物.

3. **程序内存四区模型:**

   1. ```c
      硬盘          内存                    执行过程中,c程序内存管理
      程序     -->  代码 <- 操作系统代码  ->  堆区(heap):malloc/new/free/delete 
                                              程序运行时程序员管理,程序结束后操作系统管理
                                           栈区(stack): 程序局部变量.函数里面写的都是变量.
                                                大部分都是操作系统管理.
                                           全局区(静态区)(glohal):常量和全局变量,静态变量,
                                                文字常量区, 初始化的,未初始化的,操作系统管理
                                           程序代码区(code): 操作系统托管,我们不关心.
      ```

   2. **四区模型**

      - 堆区(heap):一般由程序员分配释放(动态内存申请和释放),若程序员不释放,程序结束后'可能'由系统回收.
      - 栈区(stack):由编译器自动分配释放,存放函数的参数值,局部变量的值等.
      - 全局区(静态区)(glohal):全局变量和静态变量的存储是放在一块的,初始化的全局变量和静态变量在一块区域,未初始化的全局变量和未初始化的静态变量在相邻的另一块区域,文字常量区也放在这里该区域在程序结束后由操作系统释放.
      - 程序代码区(code): 存放函数体的二进制代码,操作系统托管,我们不关心.

      ```c
      例:
       #include <stdio.h>
       char* get_str()    //返回一个char类型(需要注意)
       {
           char *p = "asd";   //文字常量区,全局区
           return p;
       }
      
       int main(void)
      {
        char * p =NULL;   // 栈区
        int a = 10;   // 栈区   
        p = get_str();
        printf(" p = %s, p = %d",p,p );
         // %s :指针指向内存区的内容
         // %d :打印p 本身的值
        return 0;
      }
      ```

      - 栈的生长方向:(高地址->低地址),内存生长方向(低地址->高地址)
      - 在栈中变量的地址是从高到低的,而数组则是使用内存顺序 从低到高.
        -  例如:
          -  `int a; int b; printf("a= %p,b= %p",&a,&b);  // a的地址比b大.递减`
          -  `char c[10]; printf("c = %d, c+1 = %d",c,c+1);  // c+1比c大.递增`
      - 堆的生长方向:(低地址->高地址) 也就是内存方向

4. **内存操作流程:**

   1. (1) 操作系统把物理硬盘代码 load 到内存.
   2. (2) 操作系统把 c 代码分成四个区.

   



## 内存分段

==**在冯诺依曼的体系结构中必须有：代码段，堆栈段，数据段,  因为冯氏结构，本质就是取址，执行的过程**==

- ==**编译器和系统在为变量分配是从高地址开始分配的.**==
- ==**全局变量和函数参数在内存中的存储是由低地值到高地址的.**==
- **函数是在程序运行中进行动态的调用的,  函数参数就会放到堆区**
  - **在函数的编译阶段根本无法确定他会调用几次，会需要多少内存, 即使可以确定那时候就为变量分配好内存着实也是一种浪费。所以编译器为函数参数选择动态的分配..即在每次调用函数时才为它动态的进行分配空间.**



> 1. 代码段、数据段、栈是CPU级别的  **逻辑概念**，堆是语言级别的  **逻辑概念**
>
> 2. 全局变量或静态变量，放在  **数据段**，局部变量放在 **栈** 中，用new产生的对象放在 **堆** 中
>
> 3. 还有一个 **常量区**，其中的内容不许修改。常见的 char *p = "hello"; 这里面的"hello"就保存在常量区
> 4. 代码段、数据段、堆栈段，这是一个 **概念**,         堆、栈、全局区、常量区，这是 **另一个概念**



- **内存分为4段，栈区，堆区，代码区，全局变量区**

  - **全局变量区:**

    - **BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。**
      - BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

  - **数据段:**

    - 数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。 
      - **数据段属于静态内存分配。**

  - **代码段:**

    - 代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。
      - 这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读.
        - 某些架构也允许代码段为可写，即允许修改程序。
      - **在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等**。
        - 代码段是存放了程序代码的数据，假如机器中有数个进程运行相同的一个程序，**那么它们就可以使用同一个代码段。**

  - **堆 (heap) :**

    - **堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定, 可动态扩张或缩减。**
      - 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；
        当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

  - **栈  (stack):**

    - **栈又称堆栈， 是用户存放程序临时创建的局部变量**
      - 也就是说函数括弧“{}”中定义的变量（**但不包括static声明的变量，static意味着在数据段中存放变量**）。
        - 除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
        - **由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。**

    - **STACK（栈）临时局部:**
      - HEAP（堆）动态
      - RW（读写）全局
      - RO(只读)代码
        - `char* s=”Hello,World”;`  s 中  “H”  存放在内存RO中且不能修改。



## 内存分段和内存分页一样都是一种内存管理技术

1. ==内存分段和内存分页一样都是一种内存管理技术, **分段：权限保护,分页：虚拟内存.**==
2. **分段后,程序员可以定义自己的段,各段有独立的地址空间,像进程的地址空间互相独立一样.**
3. 同一个类的实例分配在一个段中,只有该类的方法可以访问,如果其他类的方法去访问, **会因为段保护而出错.可以从硬件上实现类的数据保护和隐藏**



## 分段的好处

1. **cpu中的段寄存器-------段址（base）和偏移值的上限（limit）.**
   1. 段址：有效地址 中，如果有效地址大于limit，便会引发异常。这样就可以限制程序不能访问当前段外的数据，不能访问其他程序的数据。
2. **面向对象的好处:对象就是一块连续的内存中的数据**
3. 寄存器是特殊形式的内存，嵌入到处理器内部。

- **每个进程需要访问内存中属于自身的区域，因此，可将内存划分成小的段，按需分发给进程。**
- **寄存器用来存储和跟踪进程当前维护的段。偏移寄存器（Offset Registers）用来跟踪关键的数据放在段中的位置。**
- **在进程被载入内存中时，基本上被分裂成许多小的节（section）。我们比较关注的是6个主要的节:**
  - **.text 节**
    - .text 节基本上相当于二进制可执行文件的.text部分，它包含了完成程序任务的机器指令。
      - 该节标记为只读，如果发生写操作，会造成segmentation fault。在进程最初被加载到内存中开始，
    - **该节的大小就被固定。**
  - **.data 节**
    - .data节用来存储初始化过的变量，如：int a =0 ; 
    - **该节的大小在运行时固定的。**
  - **.bss 节**
    - 栈下节（below stack section ,即.bss）用来存储未初始化的变量，如：int a; 
    - **该节的大小在运行时固定的。**
  - **堆节**
    - 堆节（heap section）用来存储动态分配的变量，位置从内存的低地址向高地址增长。内存的分配和释放通过malloc() 和 free() 函数控制。
  - **栈节**
    - 栈节（stack section）用来跟踪函数调用（可能是递归的），在大多数系统上从内存的高地址向低地址增长。同时，**栈这种增长方式，导致了缓冲区溢出的可能性。**
  - **环境/参数节**
    - 环境/参数节（environment/arguments section）用来存储系统环境变量的一份复制文件，
    - 进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell 名称、主机名等信息。
      该节是可写的，因此在格式串（format string）和缓冲区溢出（buffer overflow）攻击中都可以使用该节。
      另外，命令行参数也保持在该区域中。



> **以win32程序为例。**
> 程序执行时，操作系统将exe文件映射入内存。exe文件格式为头数据和各段数据组成。
>
> 头数据说明了exe文件的属性和执行环境，段数据又分为数据段，代码段，资源段等，段的多少和位置由头数据说明。也就是说，不仅仅只是代码段和数据段。这些段由不同的编译环境和编译参数控制，由编译器自动生成exe的段和文件格式。
>
> 当操作系统执行exe时，会动态建立堆栈段，它是动态的，并且属于操作系统执行环境。
>
> 也就是说，程序在内存的映射一个为exe文件映射，包括数据段、代码段等它是不变的。
>
> 另一个为堆栈段，它是随程序运行 动态改变的。
>
> 1. **编译器把源代码转化成分立的目标代码（.o或者.obj)文件，这些文件中的代码已经是可执行的机器码或者是中间代码。** 但是其中变量等事物的地址只是一些符号。   
> 2. 接下来是通过链接器处理这些目标代码，主要目的就是把分立的目标代码连接成一份完整的可执行代码，
>    并将其中的地址符号换成相对地址。如果这时候产生错误，我们就可以得到一份地址符号列表，而不是变量列表。
> 3. 执行程序的时候操作系统分配足够的内存空间，建立好系统支撑结构后把二进制可执行代码读入内存中。
>    在读入过程中内存首址就成了程序的“绝对地址”（实际上还是相对地址，不过是操作系统里的相对地址了）。于是绝对地址+相对地址（就是偏移量）就得到了变量的地址。   
>
> 因此，CS的值是由系统填入的，而其它S寄存器的值则是根据程序代码中附加的信息计算后得到的。





## CPU寄存器

- **CPU寄存器：CPU寄存器，其实就是来控制代码段和数据段的指令及数据读取的地方**
- CPU也有自己存放数据的地方，那就是通用寄存器里的数据寄存器:
  - 通常是EDX寄存器
- C语言里有个 **register**，就是把数据放在这个寄存器里，这样读取数据就相当的快了, 因为不用去内存找，就省去了寻址和传送数据的时间开销。
- 它还有一些寄存器是用来指示当前代码段的位置、数据段的位置、堆栈段的位置等等(注意这里存放的只是相应的代码或数据在内存中的地址，并不是实际的值，然后根据这个地址，通过地址总线和数据总线，去内存中获取相应的值)， 在执行代码的时候，指令和数据就从这里取, 它里面还有标志寄存器，用来标识一些状态位，比如标识算术溢出 等等
- **寄存器用来存储和跟踪进程当前维护的段。偏移寄存器（Offset Registers）用来跟踪关键的数据放在段中的位置。**
- **cpu中的段寄存器-------段址（base）和偏移值的上限（limit）.**
  - 段址：有效地址 中，如果有效地址大于limit，便会引发异常。这样就可以限制程序不能访问当前段外的数据，不能访问其他程序的数据。
- 

