## 目录

- [C++的输入流和输出流以及缓冲区](#C++的输入流和输出流以及缓冲区)
- [文件的读写,文件流类和文件流对象](#文件的读写,文件流类和文件流对象)
- [二进制文件操作,对象序列化](#二进制文件操作,对象序列化)
- [查看二进制数据文件](#查看二进制数据文件)
- [文件操作缓冲区](#文件操作缓冲区)



## C++的输入流和输出流以及缓冲区

- **输入和输出  是相对程序而说的.   输入输出的核心就是程序. 所有的输入输出都是程序来控制的.**
- ==**键盘输出数据到程序,  称为标准输入  `input`**==
- ==**程序数据输出到显示器, 称为标准输出  `ouput`**==
- **`标准输入 + 标准输出 = 标准 I/O`**
- **文件的输入和输出就叫 文件I/O**
- **缓冲区就是从内存开辟的一块空间而已.`(可以看成一个 char buf[1024] 这样的数组)`**
- **==输入缓冲区==.存在于键盘和程序之间,由键盘输入数据,然后程序来这里读取数据. 键盘的回车就相当于刷新缓冲区.**
- **==输出缓冲区==.存在于显示器和程序之间, 程序输出数据到缓冲区,然后刷新缓冲区后,缓冲区曾经的数据才会发送给显示器显示**
- **==在键盘(标准输入设备) 到 程序之间有个输入缓冲区的存在==**
  - **程序会到缓冲区中拿数据,如果缓冲区内没有数据,那么程序会阻塞,等待键盘进行输入,  如果缓冲区有数据, 那么就会从缓冲区读入字符**
- ==**尽量避免使用标准库提供的带有缓冲区的函数**==

```c++
#include <iostream>
using namespace std;
cout;  //全局流对象  输出数据到显示器
cin ;  //全局流对象  输入数据到程序
cerr;  // 标准错误   输出数据到显示器  没有缓冲区  因为没有缓冲区,那么数据会直接发送给显示器马上输出.
clog;  // 标准日志   输出数据到显示器  拥有缓冲区  有缓冲区,数据会存在缓冲区,等待刷新后才会发送给显示器.
endl;  // 刷新缓冲区  用来刷新缓冲区,把数据发送出去.以便下次写入新数据.


/* 
 * 标准输入流 经常使用的类成员函数: 
 */
cin.get(无参数)    // 一次只能读取一个字符. 该字符会变成返回值, ch = cin.get();
cin.get(一个参数)  // 读一个字符.  和无参数一样. cin.get(ch);
cin.get(两个参数)  // 可以读一个字符串. 括号内第一个参数是字符数组,第二个参数是读取最长的长度.
                  // 而且不会读入换行符\n .  cin.get(buf,1024);   以换行为结尾和刷新

cin.getlen(字符串,想要读取字符的数量)   // 从缓冲区读取一行放入字符串,但是这一行不能超过设定的数量.
                                    // 不会读取 换行符 '\n' 的.


cin.ignore(一或二个参数或无参数)  // 忽略当前字符 ,每次从缓冲区取走一个扔掉.这个成员函数有三种方式.
           cin.ignore()         // 忽略一个字符,从缓冲区取走一个扔掉. 无参数
           cin.ignore(20)       // 忽略连续的20个字符,从缓冲区取走20个字符扔掉 , 一个int 参数.
           cin,ignore(10,'\n')  // 忽略连续的10个字符,如果提前碰到 \n 则终止,无论是否取走够10个.

cin.peek(无参数)   // 偷窥一下缓冲区的第一个字符,并返回这个字符,但是不会从缓冲区取走字符.只是看一下.
  
cin.putback(必须是char)   // 把一个字符放回到缓冲区的第一个位置,(无论这个缓冲区是否修改过) 
                          // 应该配合 cin.get()使用. 取走一个就放回去一个.


/* 
 * 标准输出流 经常使用的类成员函数:
 */
cout.flush(无参数)     // 刷新缓冲区,立刻显示
cout.put(一个字符)     // 向缓冲区内写入一个字符, 可以支持链式编程. cout.put('a').put('b').put('c');
cout.write(字符串,字符串大小)    //向缓冲区写入一串字符串,并且写入字符串大小(strlen(串)  不用+1).

  
/*
 * 格式化输出 经常使用的类成员函数: <重点内容>
 * 要先使用 cout.unsetf(iso::dec); 取消掉十进制输出,然后才能设置其他的输出方式,否则还会是十进制输出.
 */
cout.unsetf(ios::dec);      // 卸载当前的十进制输出方式      ios::dec 表示十进制输出格式
cout.setf(ios::oct);        // 使用八进制进行输出            ios::oct 表示八进制输出格式
cout.setf(ios::showbase);   // 把 0x1 以及 02 进制符号显示出来    ios::hex 表示十六进制输出格式


cout.width(数字);       // 设置输出位宽,每次输出的都必须占用设定长度的位置,没有则使用空代替
cout.fill(一个字符);    // 将输出长度的空变成这个字符, 要配合 cout.width() 来使用,来填补空缺,默认右对齐
cout.setf(ios::left);   // 左对齐方式输出.
cout.setf(ios::right);  // 右对齐方式输出。


int number = 1;
cout << hex     // 通过控制符输出,需要引用头文件<iomanip>  这表示要用十六进制输出
     << setiosflags(ios::showbase)    // 显示十六进制和八进制的符号位  01  0x1 前面的0和0x
     << setw(10)    // 设置输出位宽, 输出长度为10 , 如果不填充则用空代替.
     << setfill('*')   // 使用 * 来代替位宽中的空缺.
     << setiosflags(ios::left)    // 左对齐方式输出
     << number      // 输出一个int的值 ,上面设置了 hex 和 setiosflags(ios::showbase),输出0x1
     << endl;       // 结束 回车
cout << 1234 << endl; // 虽然脱离了上面, 但还是延续了控制符设置.setiosflags(ios::showbase), hex

输出: 
0x1*******
0x4d2
```

- **想要使用一种格式进行输出的话,最好卸载另外的几种不需要的格式. 比如想用八进制输出,那么卸载十和十六.**

- **要注意, 如果在某个位置卸载了 十进制输出 ,而且又装载了十六或八进制输出格式的话,那么他下面的所有cout输出都会都会变成 十六或八进制, 除非再次装载十进制,而且卸载八或十六进制.(默认输出是十进制).**

- **使用控制符进行输出的话,也会对下面所有的输出进行影响,不光是调用它的这一行或是函数,而是整个程序.**   





## 文件的读写,文件流类和文件流对象

- **需要引用头文件 `<fstream>`**

- **`ifstream` 打开文件,读取文件**

- **`ofstream` 打开文件,写入文件,**

- **打开文件的两种方式: (都是类对象)**

  > **ios::in  只读方式打开文件,   ios::out  以覆盖写入模式打开文件, ios::app 以在末尾添加模式**
  >
  > **ios::binary   二进制模式** 

```c++
const char* fileName  = "/home/pi/temp/a.txt";  // 需要读取的文件.
const char* TagetName = "C:/Users/28623/Desktop/target.txt";  // 需要写入的文件.


1. ifstream ism(fileName,ios::in);   //只读方式打开文件, ios::in  是读取打开方式
   ofstream osm(TagetName,ios::out); //以写的方式打开文件,ios::out 写入方式会覆盖文件原内容
               (TagetName,ios::app); // 以添加打开文件,会从文件末尾开始写入,不会删除原内容. 
           (TagetName, ios::binary); // 以覆盖写入加二进制模式打开文件
  (TagetName, ios::binary|ios::app);  // 以添加模式加二进制打开文件(这个最好).


2. ifstream ism;      ism.open(fileName,iso::in);       // 同上 
   ofstream osm;      osm.open(TagetName,ios::out);


/* 
 * 打开后判断是否打开文件
 */
if( !ism )   // 要用取反来判断, 因为这个符号已经重载了 
{   cout<< "打开文件失败" << endl;  throw ism;  }  //出现异常

这么写只能从文件中读取内容到程序,不可以修改文件中的内容
  

/*
 * 读文件到屏幕,  一个字符一个字符的输出:
 */
char  ch ;   // 暂时保留读取到的字符
while( ism.get(ch) ){    // 判断是否读取到文件末尾, 使用 .get(ch) ,把读取到的内容赋值给ch
    cout << ch;     // 输出字符到屏幕
    osm.put(ch);    // 输出字符到文件
} 


/*
 * 关闭文件:
 */
ism.close();   // 调用 fstream 类中的成员函数 .close() 来关闭这个对象打开的文件.
osm.close();
```

- **正常的文本修改和读取和c差不多,只不过都变成了对象和类成员了.**
- ==**文本模式和二进制模式的区别就体现在win下,需要自动转换,但是linux却不需要.**==
- **文本模式打开win下文件,会自动把文件末尾的 "\r\n" 自动转换成 "\n"输入到程序中,但是把程序中的内容输入到文件中的话,就会把 "\n" 换成 "\r\n" 写入文件,这就是win下文件的读写.**

- **linux 文本模式或者二进制模式读取和写入文件都没什么区别.因为它就是"\n" 来当做行结尾的.不用转换.**
- ==**二进制读写就是把内存中的内容原封不动的写入文件.**==





## 二进制文件操作,对象序列化

- ==**对象序列化: 把类对象写入文件内,或者从文件内读取到程序内.**==

```c++
class Person {          //这是个普通类
public:
    Person() {}
    Person(int age, int id) :age(age), id(id) {}
    void Show() {
        cout << "Age: " << this->age << ",ID: " << this->id << endl;
    }
    ~Person() {}
public:
    int age;
    int id;
};



void test02() {
    //------把类对象的内存二进制数据,完整的写入文件中----
    Person p1(10, 20), p2(30, 40);
    // 把p1和p2写入文件. 这些数据在系统中都是二进制存在的.

    const char* TagetName = "C:/Users/28623/Desktop/target.txt";

    ofstream osm(TagetName, ios::out |ios::binary);  // 以二进制的写入模式打开
    osm.write((char*)&p1, sizeof(Person));    // 把p1的内存,完整的写入文件
    osm.write((char*)&p2, sizeof(Person));    // 把p2的内存,完整的写入文件
    // 因为 osm.write() 需要一个char* 类型参数和空间大小的参数,所以要强转类型

    osm.close();        // 关闭文件

    //------从文件读取内容放入到类对象中----
    ifstream ism(TagetName, ios::in | ios::binary);  // 以二进制的只读模式打开

    Person ps1,ps2;
    ism.read((char*)&ps1, sizeof(Person));
    ism.read((char*)&ps2,sizeof(Person));  //从文件读取数据覆盖并覆盖掉ps中的内容.
    // 因为 osm.read() 需要一个char* 类型参数和空间大小的参数, 所以要强转类型
    
    ps1.Show();
    ps2.Show();
};
```

- **正常的文本修改和读取和c差不多,只不过都变成了对象和类成员了.**
- **文本模式和二进制模式的区别就体现在win下,需要自动转换,但是linux却不需要.**
- **文本模式打开win下文件,会自动把文件末尾的 "\r\n" 自动转换成 "\n"输入到程序中,但是把程序中的内容输入到文件中的话,就会把 "\n" 换成 "\r\n" 写入文件,这就是win下文件的读写.**

- **linux 文本模式或者二进制模式读取和写入文件都没什么区别.因为它就是"\n" 来当做行结尾的.不用转换.**

- ==**二进制读写就是把内存中的内容原封不动的写入文件.**==

> **ios::in  只读方式打开文件,   ios::out  以覆盖写入模式打开文件, ios::app 以在末尾添加模式**
>
> **ios::binary   二进制模式** 

==**使用linux的话,应该用二进制来进行读写操作最为方便和安全.**==



## 查看二进制数据文件

```bash
　hexdump [选项] [文件]...
    -n length 只格式化输入文件的前length个字节。
    -C 输出规范的十六进制和ASCII码。 
    -c 单字节字符显示。 
    -d 双字节十进制显示。
    -o 双字节八进制显示。 
    -x 双字节十六进制显示。
    -s 从偏移量开始输出。 
    -e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：'a/b "format1" "format2"'。
```

```bash
使用vim
vim -b 二进制文件

使用命令将文件转换成进入十六进制模式
   :%!xxd 

修改文件内容时,应该使用 r 来进行替换

修改完成后,应该使用下面的命令将十六进制转换回二进制
   :%!xxd -r 
   
小端表示法 (4字节的int)
 7856 3412     转换成十进制是  305419896 ,十六进制是0x12345678
    转换过来是
      1234 5678
       每两个字节一组, 进行拆分  78 56 34 12  ,按照数据类型进行区分单元(int 是4字节)
        拆分之后进行顺序排列,前后对调 12 和 78 对调 得到  12 56 34 78  
          然后对调 56 和 34 得到   12 34  56  78 , 这就是真实的数值
```



## 文件操作缓冲区

文件操作有缓冲区 只是针对 ANSI C  (标准C),的一个库函数.   EOF 文件结束(end of file)

- 有关概念:
  - 根据文件的逻辑结构:
    - 记录文件: 具有一定结构的记录组成(定长和不定长).
    - 流式文件: 由一个个字符(字节)数据顺序组成. (我们操作的一般是这个文件)
  - 根据储存介质:
    - 普通文件: 储存介质文件.(磁盘,磁带). <放在硬盘上的文件>(嵌入式linux一切皆文件,没有设备文件)
    - 设备文件: 非存储介质(键盘,显示器,打印机).  <标准输入,标准输出 之类的>
  - 按数据的组织形式:
    - 文本文件: ASCII 文件,每个字节存放一个字符的 ASCII 码.(utf8)
    - 二进制文件: 数据按其在内存中的存储形式原样存放.
- 文件缓冲区: 每个系统的缓冲区都不一样,主要是提高效率,当写入数据的时候会临时放在缓冲区,如果有fflush()函数调用或者缓冲区已满和程序结束的时候才会把数据写入目标文件.(linux mac win 都是不一样的),
  - (考试会问,但是实际使用并不关心).
- 文件缓冲区只是针对普通文件,并不会针对设备文件(比如 stdout 直接输出到屏幕走的是设备文件),无权管理.



