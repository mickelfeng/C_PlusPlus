# Lambda表达式

- **c++11中Lambda 表达式  `用于定义并创建匿名函数对象`, 简化编程工作**

```c++
/* 下面是函数声明 */
[函数对象参数](操作符重载函数参数)mutable->返回值类型(函数体)
{  statement };

/* 下面是声明和调用 */
[函数对象参数](操作符重载函数参数)mutable->返回值类型(函数体)
{  statement }();    //  <---- 小括号是重点, 因为没有传递参数, 也就是进行调用

/* 下面是指向 Lambda 表达式的 匿名类 */
auto fun = [函数对象参数](操作符重载函数参数)mutable->返回值类型(函数体)
{  statement};

/* 通过匿名类调用 */
fun();  //和正常函数一样




// 创建一个指向 lambda 表达式的函数指针
#include <functional>
std::function<void(int)> fun = [](int a){ };
fun(10):
```

- **`[]` 标示 Lambda开始.不能省略,必须存在**
  - **函数对象参数** 是传递给编译器自动生成的函数对象,类 的构造函数的. 也可以是空
    - **函数对象参数可以有以下写法:**
      - `[]` :空, 标示没有使用任何函数对象参数.
      - `[=]`  :函数体内可以使用 Lambda 所在作用域内所有可见的局部变量(包括 Lambda所在类的this), 并且是 **值传递方式** ,就是正常的函数跳转类似.
        - `[=,&a,&b]` :a和b 都进行引用传递,其他的都是值传递.
      - `[&]` :函数体内可以使用 Lambda 所在作用返回内所有可见的局部变量(包括 Lambda所在类的this), 并且是 **引用传递方式**
        - `[&a]` : 将变量(或常量) a 按引用进行传递时
        - `[&, a,b]` :a和b都进行值传递, 其他的都是引用传递
      - `[this]`  :函数体可以使用Lambda 所在 **类中的成员变量**, 这个与 `=` 类似.
      - `[a]`  :将变量(或常量) a 按值进行传递时, 函数体内不能修改传递进来的a的 **拷贝** ,默认情况下函数是 `const` 的, **如果要修改传递进来a的拷贝,可以添加 `mutable` 修饰符到小括号后面.**
        - `[a,b]` : 将a,b 都进行值传递
- **`(操作符重载函数参数)`: 标识重载的()操作符的参数, 在没有参数时可以省略**
  - **操作符重载函数参数: 就是函数的参数列表.**
    - `double ret = [](int a, int b)->double { return 1.0; }(10,20);`
      - `// 解释: 不使用任何函数对象参数, 需要两个int的参数来运行Lambda表达式, 返回一个double类型的值赋值给 ret, 最后面的(10,20)表示运行这个表达式,并将10赋值给a,20赋值给b`
- `mutable`  :声明, 表示 **按值传递函数对象参数时`( "[]"这里面的内容)`, 添加这个声明,可以修改按值传递进来的拷贝,只是修改拷贝,无法修改本体**
  - **`[&]`  引用不需要这个参数, 直接就可以修改**
  - 这个声明可以省略;



