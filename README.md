#  目录

- [C++笔记](#C++笔记)
- [类](#类)
  - [构造函数与析构函数](#构造函数与析构函数)
- [普通函数重载](#普通函数重载)
- [inline 内联函数](#inline内联函数)
- [enum  枚举](#enum枚举)
- [左值右值 和 左值引用 以及 右值引用](#左值右值和左值引用以及右值引用)
- [占位参数\(也称默认实参\)](#占位参数\(也称默认实参\))
- 





```c++
关键字集合:
 enum 枚举,    inline 内联,    public 公有,    private 私有,    protected 保护,
 virtual 虚或纯虚,    friend 友元,    operator 操作符重载
```

- ==成员函数尾部出现 const ,修饰是 this 指针.(`const 类名 *cosnt this`).==
- 

# C++笔记

> - ==在 c 下函数的默认返回值是int, 就算是 f(){xxx} 这样写在那里,也不会出错.但是c++下不行.==
>
> -  ==在 c 下可以重定义多个同名的全局变量,会存在不同的字段(无初始化会在bss,有初始化会在data).c++下不行.==
>
> - ==一个函数的返回值就是一个无名的隐藏变量(右值),一旦当接受它的是一个想要用它来定义的初始化的值的时候,它会直接由无名隐藏变成那个值的名字,从而顶替他.(这个很重要,尤其是类的时候,这样来定义一个类是不会触发析构函数的)==

- **双目(也称双元)运算就是运算符有两个参数,(a + b  中的 + 就是双目运算符).**
- **三目运算符这样写就可以变成左值:   (开发根本用不到)**
  - `*(a < b ? &a :&b) = 50;     // 如果a小于b 则返回a 的引用,然后修改a的值,反之亦然.`
  - `(a < b ?  a : b) = 50;     // 同上,三目运算返回的是变量的引用,并不是返回某个数值,这样是可以的.`
- **const int a; 等价于 int const b;  没区别的.(`指针除外`)**
- ==const 类型的常量会在 常量区的符号表创建,而不是在栈区.没有地址`(而且还会在编译阶段把常量换成值)`==
- ==**符号表 有可能在常量区 也有可能在text段 `(内存笔记有详细记录)`;**==
  - **符号表纯粹是一个阵队`(一个key对应一个value,和一个变量名字与变量所代表的值类似.)`**
    -  一个是 key (存放变量名称) 一个是 value(存放变量数据),
    - **没有空间和地址,而且是只读不可修改的.会在编译的时候替换(不是预处理),与#define 虽然很像但不是一个东西.**
- ==**如果对一个常量取地址,编译器会临时开辟一个空间(栈),让这个指针指向存放这临时空间的地址.**==
  - ==(当然,这个临时空间内的值也就失去了常量的性质,变成 `变量` 了,可以随意更改.但是和`原常量`没关系了).==
- ==一个 `const` 的指针,当把它传递给其他函数形参的时候,接受它的也必须是 `const` 类型,否则会出现安全问题,编译也无法通过.==
- 



## 类

**三种访问级别:  `public,  private, protected`**

- ==成员函数尾部出现 const ,修饰是 this 指针.(`const 类名 *cosnt this`).==
- ==this 指针原型`(类名 *const this)`;==
- ==如果想返回一个对象的本身,在成员方法中,用 `*this` 返回.==
- ==定义类函数的时候都会隐藏的传入一个 `this` 指针常量 隐藏参数.==
- ==如果想对一个对象相续调用成员方法,每次都会改变对象本身,成员方法需要返回引用.==
- ==成员函数尾部出现 const ,修饰是 this 指针.(`const 类名 *cosnt this`).==
- ==临时创建的无名类,定义以后会立刻析构(temp(); 运行过了这一行就立刻析构,就是刚刚定义就没了).==
- ==类的声明周期结束后会调用析构函数,如果函数中有多个类,那么会实行先入后出原则,最后构造的先析构(出栈).==
- 





### 构造函数与析构函数

```c++
(int char double long 之类的这样的关键字都是类)
类 : class temp { 
    public:    // 公有成员
    private:   // 私有成员
    protected: // 保护控制权限.在类的继承中跟private有区别,再单个类中,跟private一样.
};
```

> - ==构造函数和析构函数都不允许有返回值.(定义的时候都没有那么就不应该有).==
> - 构造对象成员的顺序跟初始化列表的顺序无关,而是跟成员对象的定义顺序有关.
> - **析构函数不能有形参,而且析构也不能重载, 但是构造可以重载.**
> - 当有显示的构造函数或者显示拷贝构造函数的时候,默认无参构造函数都会被屏蔽.(但是默认拷贝构造函数还有).
> - ==类的声明周期结束后会调用析构函数,如果函数中有多个类,那么会实行先入后出原则,最后构造的先析构(出栈).==
> - ==临时创建的无名类,定义以后会立刻析构(temp(); 运行过了这一行就立刻析构,就是刚刚定义就没了).==
> - ==把拷贝函数 和 拷贝构造函数 放到 `private` 私有中,就可以拒绝对象进行拷贝了.==
>   - ==**正常的无参数构造如果放到 `private` 中, 那么代表不可以使用无参数来创建一个对象**==
> - ==使用 `new` 和 `delete` 会自动调用构造和析构的==
> - ==无论什么情况都要把  `= 号操作重载` 和 `深拷贝构造` 两个重要的成员写出来.==
> - 一个函数的返回值就是一个无名的隐藏变量,一旦当接受它的是一个想要用它来定义的初始化的值的时候, 它会直接用无名隐藏变成那个值的名字,从而顶替他.(,这样来定义一个类是不会触发析构函数的!)
>   - 返回的必须是一个引用 &
> - `memset()`;  该函数可把数组内的所有元素都初始化为 '\0'
> - ==绝对不可以出现二义性的重载构造函数.==
>   - ==例如:   `temp():a(0) {}`   和 `temp(int i=0):a(i) {}` , 是相同的, 绝对不可以这么写==

```c++
构造函数:
    构造函数 是生成(定义)时候触发,析构是结束时触发.
    构造函数 需要在 public 内,也可以在 private内:
	class temp{
    public:
    temp (int t, int a=0):t1(t),a1(a)  /*a=0 是默认参数, :后面的是初始化列表  */
      {/*这里面的内容可有可无,跟正常的函数体一样*/ }
    temp():tl(0),al(0) {}     /* 重载构造函数*/
    private:
    int tl, al;s
  };

拷贝构造函数:
    拷贝构造函数也在 pubilc 内:  (多多注意深拷贝和浅拷贝以及内存分配问题)
	      temp (cosnt temp & tempthis) { 
           this->t1 = tempthis.t1; this->a1 = tempthis.a1;   //浅拷贝
        } 
     这么写:
        temp (const temp& tempthis):t1(tempthis.t1),a1(tempthis.al) {};
      
    这个拷贝构造函数在使用的时候有两种调用方式:
        temp t1;  
        temp t2 = t1;   
        temp t3(t1);
        temp t4;
        t4 = t3;
        void tempfun(temp t);
        // 函数形参的值传进来也会调用拷贝构造
        // 这几种种赋值方式都会调用同一个拷贝构造函数,所以他们是等价的.
        void  tempfun(temp& t); 
          // 这种不会进行拷贝构造,因为是引用.
```

```c++
析构函数
  析构函数也要在 public 内:
  ~temp() { /*里面是用来释放内存之类的操作 */ }
    /* 带指针的类必须有析构函数, 数值类可以不要(容器除外) */
```





## 普通函数重载

> - `函数的返回值,函数形参列表(参数的个数,参数的类型,参数顺序){};`
> - ==函数重载的必要条件:  函数名相同, 参数列表不一样,参数个数不同.==
>   - ==函数返回值并不是构成函数重载的条件.==
>   - (在c 中实际这重载函数并不是同样的文件名,都是被更改过的,然后去替换)

```c++
普通函数重载实现原理:用v c i f l d 表示 void,char,int,float,long,doube以及其他引用,然后写入函数名后.
	void func(char a) ;    //在编译时候就变成了, func_c(char a);
	int  func(int a, double b,char c);   //在编译时候就变成了, func_idc(int a, double b,char c);
```





### inline内联函数

函数是否真的会变成 inline 是由编译器来决定的, 通常函数越短, 就越有可能让编译器做成inline.

==**可以提高性能**==

```c
inline   double 
  函数名  ( 参数1 , 参数2)
{
 函数体.   
}
```







## enum枚举

```c++
 enum 枚举类型范式:

    enum Season{ ziro = 0, one , two };   //声明
    int main(void)
    {
        enum Season vod = one;  // 定义了 vod 等于 one 代表的值 也就是1
        if (vod == one )    // 尽量来这样比较和使用
        { 
           ......
        }
    }
```



## 左值右值和左值引用以及右值引用

- ==**左值 可以在多行使用, 如果不是 `const`的左值,那么就可以随意修改,如果是`const`  则不可以修改.**==

- ==**右值 就是一个临时变量, 只能在当前行使用,而且不可以进行直接的引用.`(在C++11标准中可以&&来对引用,取地址,也就是 右值引用)`**==

- ==**关于引用中的左值引用和右值引用的区分:**==

  -  **& 一个引用符号是左值引用** 
    - **常量左值引用  可以接受左值、右值、常量左值和常量右值**
    - **非常量左值引用只能接受左值**
  - **&& 是右值引用, 这个右值引用解决了模版的一些问题,如果遇到问题可以尝试.**
    - **如果出现在函数模版声明中, 那么可能是左值引用也有可能是右值引用, 具体需要看传入的参数是左值还是右值了.**

- ==**右值引用可以解决以下形式类似的问题:`(尤其是存在重载的时候,这个时候要运行试一试)`**==

  - ```c++
    void func(int&& x){ cout << x << endl; }  //传入值是一个int
    
    func(3);  
     //可以直接传入常量,而不是一个对象.(如果不提供 func(int&&),那么会调用 func(const int &))
     // 当然这是有重载的时候发生的情况.
    ```

  - ```c++
    引用的本质就是 type * const T_Nmae;   就是个指针常量,不能修改指向.
        如果我们去研究引用的时候,可以把引用当做一个常指针去研究,
        无法引用右值,比如 100 这个数值是不可以直接引用的,但是却可以 双重引用 使用两个&&符号来对引用,取地址. 
        当我们在使用引用编程的时候,你就可以吧引用理解为变量的别名就可以了.
        把引用当做超级指针来看最好.
        还有种比较绕口的: (就是一个指针的引用)
            struct cer { int i;};  //一个结构
            int fun(struct cer* &tmp)  // 一个函数  形参是结构类型的指针的引用
            {  tmp = (struct cer*)malloc(sizeof(struct cer)); } // 直接就可以当申请内存当指针
    ```

- 





### 占位参数\(也称默认实参\)

```c++
 占位参数:存在于函数形参列表中,主要用途是 亚元 ,其实就是一个没有任何意义的参数,为了占位置.
    例;  
    int fun(int a,int b,int);    // 第三个参数是用不到的,但是调用的时候还是得传递参数.
    int fun(int a,int b,int = 0);    // 与上面相同只不过有个默认参数.
```



