> `智能指针: 需要头文件 <memory>, 实际上智能指针就是一个类,   //智能指针会自动回收空间`

- **`auto_ptr<> ;`已经弃用了. 现在的替代方案是` shared_ptr<>  //使用方法和 auto_ptr<>差不多.`**

- **智能指针可以避免内存泄露**

### 普通指针的三个必要素

1. **定义一个指针,指针要指向一个变量**
2. **建立关联.**
3. **开辟空间,间接赋值.**



### 可以自定义智能指针

**通过重载 -> 和 * 解指针 来自定义智能指针.(能用模板的话就要强纽成相应的类型来释放空间,不可以使用void* 来释放,坑)!**



### 指针和智能指针和使用智能指针范例

```c++
普通指针:  A* pa = new A(10);   // A是个类,调用了形参int的构造函数,

#include <memory>
智能指针:  shared_ptr<int>    // 写到这里表示 这是一个指向 int 类型的智能指针,这是数据类型.不是变量
  
          shared_ptr<A> ptr(new A(10));  
           /* 创建一个智能指针,叫ptr,其实就是个对象,接受一个 new A 的匿名对象的指针(不能写等号) 
            * ptr 是变量名.()括号内的是地址, 调用的是它的构造函数, ptr就指向 (new A)匿名对象的地址.
            * 然后 (10) 来调用类 A 中的构造函数来初始化A对象. 返回地址给 ptr.
            */

使用智能指针:
使用: *pte = 20;    // 跟正常指针差不多. 但是不需要 delete 来释放空间,他会在结束后自动调用自身的析构函数.
```

