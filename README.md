#  目录

- [C++笔记](#C++笔记)
- [类](#类)
  - [构造函数与析构函数](#构造函数与析构函数)
  - [static属性的构造函数和成员以及在private中的构造函数](#static属性的构造函数和成员以及在private中的构造函数)
  - [常量成员函数](#常量成员函数)
  - [友元](#友元)
  - [操作符重载](#操作符重载)
- [普通函数重载](#普通函数重载)
- [占位参数\(也称默认实参\)](#占位参数-也称默认实参)
- [inline 内联函数](#inline内联函数)
- [enum  枚举](#enum枚举)
- [左值右值 和 左值引用 以及 右值引用](#左值右值和左值引用以及右值引用)
- [临时对象](#临时对象)
- 





```c++
关键字集合:
 enum 枚举,    inline 内联,    public 公有,    private 私有,    protected 保护,
 virtual 虚或纯虚,    friend 友元,    operator 操作符重载

单词集合:
      by reference  引用,          value 值,   
 pass by reference  传递引用,      calss body  类结构体
   

```

- ==成员函数尾部出现 const ,修饰是 this 指针,就不允许修改对象的任何数据内容.(`const 类名 *cosnt this`).==
- **参数传递尽量都使用引用, 如果不想被修改,那么可以添加 const 参数, 返回值也是一样可以使用引用.**
- ==***如果函数返回一个 值(不是引用), 那么可以使用 `&& 右值引用` 来避免昂贵的构造,拷贝,析构的资源.***==
- ==***相同的 `class` 的各个 `objects` 互为友元.***==
- **在类中的成员函数 结尾能加 `const` 就尽量加上.**
  - ==**结尾没有 `const` 的成员函数, 是无法让 `const` 限定创建出来对象使用的.**==
- 
- 

# C++笔记

> - ==在 c 下函数的默认返回值是int, 就算是 f(){xxx} 这样写在那里,也不会出错.但是c++下不行.==
>
> -  ==在 c 下可以重定义多个同名的全局变量,会存在不同的字段(无初始化会在bss,有初始化会在data).c++下不行.==
>
> - ==一个函数的返回值就是一个无名的隐藏变量(右值),一旦当接受它的是一个想要用它来定义的初始化的值的时候,它会直接由无名隐藏变成那个值的名字,从而顶替他.(这个很重要,尤其是类的时候,这样来定义一个类是不会触发析构函数的)==

- **双目(也称双元)运算就是运算符有两个参数,(a + b  中的 + 就是双目运算符).**
- **三目运算符这样写就可以变成左值:   (开发根本用不到)**
  - `*(a < b ? &a :&b) = 50;     // 如果a小于b 则返回a 的引用,然后修改a的值,反之亦然.`
  - `(a < b ?  a : b) = 50;     // 同上,三目运算返回的是变量的引用,并不是返回某个数值,这样是可以的.`
- **const int a; 等价于 int const b;  没区别的.(`指针除外`)**
- ==const 类型的常量会在 常量区的符号表创建,而不是在栈区.没有地址`(而且还会在编译阶段把常量换成值)`==
- ==**符号表 有可能在常量区 也有可能在text段 `(内存笔记有详细记录)`;**==
  - **符号表纯粹是一个阵队`(一个key对应一个value,和一个变量名字与变量所代表的值类似.)`**
    -  一个是 key (存放变量名称) 一个是 value(存放变量数据),
    - **没有空间和地址,而且是只读不可修改的.会在编译的时候替换(不是预处理),与#define 虽然很像但不是一个东西.**
- ==**如果对一个常量取地址,编译器会临时开辟一个空间(栈),让这个指针指向存放这临时空间的地址.**==
  - ==(当然,这个临时空间内的值也就失去了常量的性质,变成 `变量` 了,可以随意更改.但是和`原常量`没关系了).==
- ==一个 `const` 的指针,当把它传递给其他函数形参的时候,接受它的也必须是 `const` 类型,否则会出现安全问题,编译也无法通过.==
- **参数传递尽量都使用引用, 如果不想被修改,那么可以添加 const 参数, 返回值也是一样可以使用引用.**
- 



## 类

**三种访问级别:  `public,  private, protected`**

- ==成员函数尾部出现 const ,修饰是 this 指针,也不允许修改`const`对象的任何数据内容.(`const 类名 *cosnt this`).==
  - ==**在C++中，只有被声明为const的成员函数才能被一个const类对象调用,也就是说 const 的对象是不可以调用 非const的成员函数的.**==
- ==this 指针原型`(类名 *const this)`;==
- ==如果想返回一个对象的本身,在成员方法中,用 `*this` 返回.==
- ==定义类函数的时候都会隐藏的传入一个 `this` 指针常量 隐藏参数.==
- ==如果想对一个对象相续调用成员方法,每次都会改变对象本身,成员方法需要返回引用.==
- ==临时创建的无名类,定义以后会立刻析构(temp(); 运行过了这一行就立刻析构,就是刚刚定义就没了).==
- ==类的声明周期结束后会调用析构函数,如果函数中有多个类,那么会实行先入后出原则,最后构造的先析构(出栈).==
- **所有的成员函数,都拥有一个隐藏参数, 就是指向本类对象的指针 `this`**
- 





### 构造函数与析构函数

```c++
(int char double long 之类的这样的关键字都是类)
类 : class temp { 
    public:    // 公有成员
    private:   // 私有成员
    protected: // 保护控制权限.在类的继承中跟private有区别,再单个类中,跟private一样.
};
```

> - ==构造函数和析构函数都不允许有返回值.(定义的时候都没有那么就不应该有).==
> - 构造对象成员的顺序跟初始化列表的顺序无关,而是跟成员对象的定义顺序有关.
> - **析构函数不能有形参,而且析构也不能重载, 但是构造可以重载.**
> - 当有显示的构造函数或者显示拷贝构造函数的时候,默认无参构造函数都会被屏蔽.(但是默认拷贝构造函数还有).
> - ==类的声明周期结束后会调用析构函数,如果函数中有多个类,那么会实行先入后出原则,最后构造的先析构(出栈).==
> - ==临时创建的无名类,定义以后会立刻析构(temp(); 运行过了这一行就立刻析构,就是刚刚定义就没了).==
> - ==把拷贝函数 和 拷贝构造函数 放到 `private` 私有中,就可以拒绝对象进行拷贝了.==
>   - ==**正常的无参数构造如果放到 `private` 中, 那么代表不可以使用无参数来创建一个对象**==
> - ==使用 `new` 和 `delete` 会自动调用构造和析构的==
> - ==无论什么情况都要把  `= 号操作重载` 和 `深拷贝构造` 两个重要的成员写出来.==
> - 一个函数的返回值就是一个无名的隐藏变量,一旦当接受它的是一个想要用它来定义的初始化的值的时候, 它会直接用无名隐藏变成那个值的名字,从而顶替他.(,这样来定义一个类是不会触发析构函数的!)
>   - 返回的必须是一个引用 &
> - `memset()`;  该函数可把数组内的所有元素都初始化为 '\0'
> - ==绝对不可以出现二义性的重载构造函数.==
>   - ==例如:   `temp():a(0) {}`   和 `temp(int i=0):a(i) {}` , 是相同的, 绝对不可以这么写==

```c++
构造函数:
    构造函数 是生成(定义)时候触发,析构是结束时触发.
    构造函数 需要在 public 内,也可以在 private内:
	class temp{
    public:
    temp (int& t, int& a=0):t1(t),a1(a)  /*a=0 是默认参数, :后面的是初始化列表  */
      {/*这里面的内容可有可无,跟正常的函数体一样*/ }
    temp():tl(0),al(0) {}     /* 重载构造函数*/
    private:
    int tl, al;s
  };

拷贝构造函数:
    拷贝构造函数也在 pubilc 内:  (多多注意深拷贝和浅拷贝以及内存分配问题)
	      temp (cosnt temp& tempthis) { 
           this->t1 = tempthis.t1; this->a1 = tempthis.a1;   //浅拷贝
        } 
     这么写:
        temp (const temp& tempthis):t1(tempthis.t1),a1(tempthis.al) {};
      
    这个拷贝构造函数在使用的时候有两种调用方式:
        temp t1;  
        temp t2 = t1;   
        temp t3(t1);
        temp t4;
        t4 = t3;
        void tempfun(temp t);
        // 函数形参的值传进来也会调用拷贝构造
        // 这几种种赋值方式都会调用同一个拷贝构造函数,所以他们是等价的.
        void  tempfun(temp& t); 
          // 这种不会进行拷贝构造,因为是引用.
```

```c++
析构函数
  析构函数也要在 public 内:
  ~temp() { /*里面是用来释放内存之类的操作 */ }
    /* 带指针的类必须有析构函数, 数值类可以不要(容器除外) */
```



### static属性的构造函数和成员以及在private中的构造函数

**这种写法是 `singleton` 设计模式**

```c++
class A{
  public:
    static  A& getInstall();   /* static 必不可少,因为返回的必须是静态对象,返回值可以当作左值来使用*/
    int setup() { std::cout << "OK" << std::endl; return this->sum; };
  private:
    int sum = 0;    /* 这个数据是不是 static 无所谓的 */
    A():sum(0){};      /* 私有构造函数 */
    A (const A& rhs):sum(0){};   /* 私有拷贝构造函数 */
    
};

A&
A::getInstall(){
 static A a; /* 返回的是一个静态对象,使用的是在private中的默认构造,进程启动时默认创建的对象,在data段 */
 return  a;
}


/* 使用 */
int main(void){
    cout << A::getInstall().setup() << endl;  /* 直接这样使用即可, 不需要手动构造 */
  return 0;
}
```



### 常量成员函数

- ==成员函数尾部出现 const ,修饰是 this 指针,也不允许修改`const`对象的任何数据内容.(`const 类名 *cosnt this`).==

- ==**在C++中，只有被声明为const的成员函数才能被一个const类对象调用,也就是说 const 的对象是不可以调用 非const的成员函数的.**==

```c++
class A{
  public:
		A(int& t):num(t) {}
    void printf() const {std::cout << num << endl;};  
  					/* 成员函数后面的const限制的是this指针,也就是变成了不可修改,非const对象也可以调用*/
  
    void pttr()     {std::cout << num << endl;};  
           /* 这个成员函数后面没有 const 关键字, 那么 有const 修饰的A对象, 是不可以调用这个函数的*/
  private:
  	int num;
};
```



#### 友元

> - ==友元函数不是定义而是声明==
> - 友元声明写在类内的任何地方都可以,因为仅仅只是声明.
> - 友元可以直接访问类内的私有成员.
> - **友元的作用是提高了程序的运行效率(即减少了类型检查和安全性检查等都需要时间开销).**
> - ==友元的弊端: 破坏了类的封装和隐蔽性,使得非成员函数可以访问类的私有成员.==
> - **==同类对象间无私处,异类之间有友元.==**
> - ==友元关系不能被继承.==
> - ==友元类是单向访问的`(temp 声明了 ent的类, ent 可以随意访问 temp, 但是temp 不可以访问 ent)`.==
> - **友元没有传递性.**
>   - (若类B 是类A 的友元,类C 是类B 的友元,则类C 不一定是类A 的友元,同样要看类中是否有相应声明).
> - ==***相同的 `class` 的各个 `objects` 互为友元.***==
> - 不建议使用 !!

```c++
class temp{
  public:
	friend double Point();    // 使 point() 函数成为temp 类的友元 (原型 double Point()).
	friend class ent;    // 声明一个友元类,ent可以随意访问tmep的所有私有成员,但temp不可访问ent私有成员
	friend double ent::Poble();   // 使 ent 类中的成员函数 Poble() ,成为temp类的友元.
};
```



### 操作符重载

- **操作符分为 成员函数和非成员函数**
  - **操作符重载可以写在类内成为针对这个类的对象来使用的, 还可变成全局的,对所有类型和对象使用**
- ==**传入参数 第一个是符号前面的 ,第二个是符号后面的,如果在类内 `this` 会成为第一个,后传入是第二个**==
  - **如果传入两个和this不相干的参数(比如`int cout,char c1`) 则可以不理会this,  而且 cout 会成为第一个 c1第二个**
  - ==不可以修改操作符的使用规则  cout << c1; 不能修改为 c1.operator(cout);  绝对不能==
  - **如果传入两个和this不相干的参数(比如cout,c1) 则可以不理会this,  而且 cout 会成为第一个 c1第二个**
- **操作符相当于替代了 计算用的函数**
- ==**不可以修改操作符的使用规则  cout << c1; 不能修改为 c1.operator(cout);  绝对不能**==
- **所有的操作符重载, 都会传入一个隐藏参数 `this` 指针 ,它指向调用者的对象.**
- ==**做操符会作用在左边的数据上, 如果是对象的话,就回去对象中寻找操作符重载,并调用.**==
  - **也就是 `this` 指针所指向的数据, 调用者.**
    - `A+=B;    //A和B都是类对象`
    - `this 指向的就是 A`
- **传递者无需知道 接受者是以 reference(引用) 形式接收.**
- **加号+ 和减号- 的重载要和  正号+ 和负号-  区分开来**
  - 加减 需要两个参数成员, 返回无名临时的一个值
  - 正负 需要一个参数成员, 返回无名临时的一个值
- ==**`>>` 和 `<<`  右移和左移操作符重载 必须写在全局, 绝对不可以写到类内变成成员函数**==
  - **需要两个参数 一个 `std::ostream 或 std::istream`的引用,  另一个是 你想要输出的对象或其他的什么类型的东西的引用**
  - **返回值必须是 `std::ostream或std::istream`的引用, 用以多次调用 << 做预测.**
- ==**运算符++可以在前可以在后,如果多次++ 则必须在前,不能在后(++++a;可以, a++++; 不可以)**==
  - ==想要重载则必须使用.函数重载. 来区分表示前++ 和后++.==
    - ==***类内成员的 后置++ 操作符重载, 必须给一个 `int` 类型的占位参数. 前置不需要参数.***==
  - ==如果想重载这个运算符,就应该把前++ 和后++ 都写上就最好了.==
  - ==***如果重载的是全局的 就给一个参数 ,如果是类内局部的就没有参数***==
- ==**重载了运算符 ()  小括号的对象, 称这种行为的对象是 仿函数, 伪函数,或者 函数对象 .  三个名字.**==
  - **可以将一个对象当成一个普通函数来调用. 只要适当的修改形参的数量和类型就可以达到重载函数的作用.**
  - **称这种行为的对象是 仿函数, 伪函数,或者 函数对象 .  三个名字.**

```c++
class temp{
 public:
    temp (int a1 = 0, int b1 = 0, int arr1[10] = NULL ): a(a1), b(b1) 
    {   if (arr1 == NULL ){
    		   arr = { [ 0 ... 9 ] = 0 } ;
           return;
    		}
        for ( int i =0; i < 10; i--)
           arr[i] = arr1[i];
    }
    temp (const temp& t): a(t.a), b(t.b) 
    {
        for ( int i =0; i < 10; i--)
           arr[i] = t.arr[i];
    }
  	int& WR_a() { return a; };
    int& WR_b() { return b; };
    int& WR_arr(int i) {  if (i > 9) {std::cout << "越界\n"; return -1;}  return arr[i]; }
  
    temp  operator+(temp &) const ;
    temp& operator+= (const temp& );
    temp& operator-= (const temp& ); 
    temp& operator++ ();          // 前置++
    temp  operator++ (int );     // 后置++
    temp& operator= (const temp& );
    int&  operator[] (int );
    int   operator() (int );
    void* operator new(size_t);
    void* operator new[] (size_t);
    void* operator delete (size_t);  
    void* operator delete[] (size_t);
  
 private: 
    friend temp& operator+= (temp&, temp&);// 友元减等, 跟上面有冲突了, 两者选其一即可
    int a, b;
    int arr[10];     // 注意深拷贝, 但是不涉及 加减法 以及 += 和 -= 的改变
};

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* 加 操作符重载: */
 inline temp 
 temp::operator+ (const temp& p) const{//操作符重载类内部标准模版operator+构成函数名,中间不能有空格
	  return temp (this->a + p.a, this->b + p.b );   // 直接返回一个匿名对象
  } 

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* 加等 操作符重载: */
 inline temp&
 temp::operator+= (const temp& p) {
   this->a += p.a;
   this->b += p.b;
   return *this;
 }

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* 加等 友元操作符重载 (也就是全局操作符重载), 如果这么写的话,全局和类内部就冲突了,那么留下一个就好了 */
 inline  temp&
 operator+= (temp& l, const temp& r){
 	 l.a += r.a;           //因为是友元 所以可以直接访问内部数据.
   l.b += r.b;
   return l;
 }

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* 减等  友元操作符重载 */
inline temp&
operator-= (const temp& p){
   this->a -= r.a;
   this->b -= r.b;
   return *this;
}

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* ++ 自增 操作符重载 , ++可在前可在后, 如果多次++, 则必须在前. (++++++temp) 自增3次*/
  /* 想要重载则必须使用.函数重载. 来区分表示前++ 和后++. */ 
  /* 如果想重载这个运算符,就应该把前++ 和后++ 都写上就最好了. */
  /* 如果重载的是全局的 就给一个参数 ,如果是类内局部的就没有参数 */
 inline temp&
 temp::operator++ (){ // 类内 重载的是前置++  先加 后使用 ,可以连加
 	 this->a++;
   this->b++;
   return *this;
 }

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
 inline temp               // int t  是占位参数,没用处.
 temp::operator++ (int t){ // 类内 重载的是后置++  先使用 后加 ,不能连加
 	 this->a++;
   this->b++;
   return temp(this->a -1, this->b -1);
 }

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* 全局 ++ 自增操作符, 和 类内的差不多, 函数体内容差不多 */
 inline tmep&
 operator++ (temp& t ) { ...; return t; }     // 前置++, 可连加
 inline temp 
 operator++ (temp& t, int p) { ...; return temp(this->a -1, this->b -1); } //后置++ ,不可连加

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/*  << >> 最为常用的左移右移操作符 重载: (!!只能写在全局,绝对不要写在类内!!), 可连续输入 */
 inline  std::ostream&
 operator<< (std::ostream& os, const temp& p){
    os << ' ' <<p.WR_a << " , " << p.WR_b << ' ' << " , arr:";  
   	for (int i =0; i<10 ; i++)
      os << p.WR_arr(i) << ' ';
    return os << std::endl;
 }

 inline std::istream&
 operator>> (std::istream& is, temp& p){
    std::cout << "a: ";
    is >> p.WR_a;
   std::cout << "b: ";
   is >> p.WR_b;
   std::cout << "arr[10]: "
   for (int i=0; i<10 ; i++)
     is >> p.WR_arr(i);
   return is;
 }

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* = 等号 运算符重载, 注意内存空间和自身赋值, 还有深拷贝和内存泄漏 */
  inline temp& 
  temp::operator= (const temp& t){    // 可连续赋值
    if (this == &t){   // 放置自身赋值,需要判断地址,( temp t =  temp t );
    	return *this;
    }
    this->a = t.a;
    this->b = t.b;
    for (int i=0; i<10 ; i++)
       this->arr[i] = p.arr[i];
    return *this;
  }

/* 替换规则 =========================================================================== */
temp p = p1 + p2;  /*等价于*/  temp p = operator+(p1,p2);  // 内部替换
temp p = p1 - p2 - p3; /*运算规则是*/ temp p = operator-(operator-(p1,p2),p3);   //替换规则
/* =================================================================================== */

/* [] 重载 数组运算符, 其实返回的就是 对象内 某个数组类型的 数组值. */
    inline int&  
    temp::operator[] (int i){
      if ( i>9 ){
        std::cout << "越界"
        return -1;
      }
      return this->arr[i];
    }

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* () 重载小括号:(经常用在sql内)  */
   inline int 
   temp::operator() (int n){ // 第一个括号是运算符重载,第二个是需要传入的参数
      return this->a * n;    // 随便写的,这些东西基本上都会用在sql内使用,而且各种各样的重载版本
   }
      使用范例:  temp p ; int a = p(10);  //a 就等于了 10* (p.a);

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
/* new delete 重载操作符: (new 应该返回一个万能指针),这里可以在operatou和 new delete 中间出现空格. */
  /* new[] delete[] 重载操作符, 就是数组 */
   inline void* 
   temp::operator new(size_t size){   // 返回一个指向内存的万能指针.
	     return  malloc(size);  // 虽然只是使用了malloc 来代替,但是可以触发 构造函数 来给类分配空间和值
   }                          // size 这个参数是默认的  sizeof(temp) , 不会被修改.

   inline void*                     // 虽然这两个声明不同, 但是内容相同.
   temp::operator new[] (size_t size){
       return  malloc(size);
   }
    使用范例和解读:  
        temp* p = new temp(10); // 申请内存空间,调用形参为一个int 的构造函数.
               /*解析原型为: temp p(temp->operator new(sizeof(temp)))(10); */
        temp* p1 = new temp;    // 申请内存空间,调用一次默认构造函数
        temp* p2 = new temp[10] // 申请内存空间,调用10次默认构造函数.与 new 重载无关, 是new[]
       // 解析原型: p2->operator new[](sizeof(temp[10]));    //会触发 20次默认构造
       // 但是需要 operator delete[](void* p);  来释放,  因为new[] 数组 就需要 delete[]  这是定则.

   inline void
   temp::operator delete (void* p){   // 因为上面申请的是一个void指针,所以这里也用void也更好.
   		if ( p ) 
        free(p);      // 也会触发 析构! ,因为new 是给类来分配空间 ,所以直接释放类就好了.
      p = NULL;
     }

   inline void
   temp::operator delete[] (void* p){ // 与上面的 new[] 来对应,要不然可没法析构数组new[] 了
    	if ( p ) 
         free(p);   // 也会触发 析构,并且是多次触发! 因为new 是给类来分配空间 ,所以直接释放类就好了.
      p = NULL;
   }
       调用范式: delete p;     // 直接定义的p 直接释放.
                delete [] p2;  // 因为是数组所以这样来释放,一一对应,因为p2有10个元素,就会触发10次析构

/*&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
!&& || 操作符重载:(别用,不能和正常操作符有用一种操作,而且不稳定,也可能会出现编译报错)


```

- operator+ 构成函数名,中间不能有空格,而且可以写在全局也可以写在类内部.
- 操作符重载的返回值一定要小心,尽量返回一个值,而不是引用(引用很少很少用).
- c++不允许用户自定义新的运算符,只能对已有的c++运算符进行重载.
- 很多运算符都可以重载,但是` .()成员选择 .*(成员对象选择)  ::(域解析) ?:(条件操作符)`这四个运算符不可以重载定义.
- 不允许改变原有操作符的基本意思,以及运算符需要的对象数量.( 比如 a+b 需要a和b  但是a+ 放这里就意义不明了).
- 当重载了 + 和* 运算符之后,c++还是按照 先算乘除 *  后算加减来进行运算的.不能改变运算符的优先级别.
- 重载不能改变运算符的结合性.(如 赋值运算符"=" 是右结合性(自右向左),重载后仍为右结合性).
- 重载运算符的函数形参不可以出现默认的参数.`(temp operator+(temp &p1,temp &p2 = 0); //这样是不可以的`
- 重载运算符必须和用户定义的自定义类型的对象一起使用,其参数至少应有一个是类对象(或类对象的引用).
- 重载运算符不可以曲解原先运算符的本意( a + b 为加法,  不可以出现重载为减法的样式).
- 运算符重载函数可以写在类内,也可以写在类外然后变成类的友元函数,都是可以的.
- 重载双目运算就是运算符有两个参数,(a + b  中的 + 就是双目运算符).
- ==无论什么情况都要把 = 号操作重载和 深拷贝构造 两个重要的成员写出来.==



## 普通函数重载

> - `函数的返回值,函数形参列表(参数的个数,参数的类型,参数顺序){};`
> - ==函数重载的必要条件:  函数名相同, 参数列表不一样,参数个数不同.==
>   - ==函数返回值并不是构成函数重载的条件.==
>   - (在c 中实际这重载函数并不是同样的文件名,都是被更改过的,然后去替换)

```c++
普通函数重载实现原理:用v c i f l d 表示 void,char,int,float,long,doube以及其他引用,然后写入函数名后.
	void func(char a) ;    //在编译时候就变成了, func_c(char a);
	int  func(int a, double b,char c);   //在编译时候就变成了, func_idc(int a, double b,char c);
```





## 占位参数-也称默认实参

```c++
 占位参数:存在于函数形参列表中,主要用途是 亚元 ,其实就是一个没有任何意义的参数,为了占位置.
    例;  
    int fun(int a,int b,int);    // 第三个参数是用不到的,但是调用的时候还是得传递参数.
    int fun(int a,int b,int = 0);    // 与上面相同只不过有个默认参数.
```



## inline内联函数

函数是否真的会变成 inline 是由编译器来决定的, 通常函数越短, 就越有可能让编译器做成inline.

==**可以提高性能**==

```c
inline   double 
  函数名  ( 参数1 , 参数2)
{
 函数体.   
}
```







## enum枚举

```c++
 enum 枚举类型范式:

    enum Season{ ziro = 0, one , two };   //声明
    int main(void)
    {
        enum Season vod = one;  // 定义了 vod 等于 one 代表的值 也就是1
        if (vod == one )    // 尽量来这样比较和使用
        { 
           ......
        }
    }
```



## 左值右值和左值引用以及右值引用

- ==**左值 可以在多行使用, 如果不是 `const`的左值,那么就可以随意修改,如果是`const`  则不可以修改.**==

- ==**右值 就是一个临时变量, 只能在当前行使用,而且不可以进行直接的引用.`(在C++11标准中可以&&来对引用,取地址,也就是 右值引用)`**==

- ==**关于引用中的左值引用和右值引用的区分:**==

  -  **& 一个引用符号是左值引用** 
    - **常量左值引用  可以接受左值、右值、常量左值和常量右值**
    - **非常量左值引用只能接受左值**
  - **&& 是右值引用, 这个右值引用解决了模版的一些问题,如果遇到问题可以尝试.**
    - **如果出现在函数模版声明中, 那么可能是左值引用也有可能是右值引用, 具体需要看传入的参数是左值还是右值了.**

- ==**右值引用可以解决以下形式类似的问题:`(尤其是存在重载的时候,这个时候要运行试一试)`**==

  - ```c++
    void func(int&& x){ cout << x << endl; }  //传入值是一个int
    
    func(3);  
     //可以直接传入常量,而不是一个对象.(如果不提供 func(int&&),那么会调用 func(const int &))
     // 当然这是有重载的时候发生的情况.
    ```

  - ```c++
    引用的本质就是 type * const T_Nmae;   就是个指针常量,不能修改指向.
        如果我们去研究引用的时候,可以把引用当做一个常指针去研究,
        无法引用右值,比如 100 这个数值是不可以直接引用的,但是却可以 双重引用 使用两个&&符号来对引用,取地址. 
        当我们在使用引用编程的时候,你就可以吧引用理解为变量的别名就可以了.
        把引用当做超级指针来看最好.
        还有种比较绕口的: (就是一个指针的引用)
            struct cer { int i;};  //一个结构
            int fun(struct cer* &tmp)  // 一个函数  形参是结构类型的指针的引用
            {  tmp = (struct cer*)malloc(sizeof(struct cer)); } // 直接就可以当申请内存当指针
    ```

- 



### 临时对象

```c++
class A{
	public:
  	A (const A& a ):t(a.t) {};
  private:
  	int t;
};

A                     // 绝对不可以返回 引用 reference
print (const A& a){
	return  A (a);    //这个函数返回的就是一个匿名的临时对象, 
}
```



